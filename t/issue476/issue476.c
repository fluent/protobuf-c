/* File: issue476.c
 * Unit test for proto3 `optional` support generated by protoc-gen-c.
 *
 * The test:
 *  - constructs a TestOptional message, sets several optional fields (and oneof),
 *    packs, unpacks and checks the presence flags (has_*), oneof case, repeated values
 *  - asserts are used for validation.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <math.h>

#include "t/issue476/issue476.pb-c.h"  /* generated by protoc + protoc-gen-c */

/* helper to allocate and set a repeated int32 array */
static void set_repeated_int32(TestOptional *msg, uint32_t count, const int32_t *values)
{
    msg->n_rep_int32 = count;
    msg->rep_int32 = malloc(sizeof(int32_t) * count);
    for (uint32_t i = 0; i < count; ++i) {
        msg->rep_int32[i] = values[i];
    }
}

int main(void)
{
    /* Initialize message (sets base.descriptor and zeroes fields) */
    TestOptional msg = TEST_OPTIONAL__INIT;

    /* Set some optional scalar fields and mark presence */
    msg.opt_int32 = 12345;
    msg.has_opt_int32 = 1;

    msg.opt_int64 = -1234567890123LL;
    msg.has_opt_int64 = 1;

    msg.opt_uint32 = 4000000000U;
    msg.has_opt_uint32 = 1;

    msg.opt_uint64 = 900000000000ULL;
    msg.has_opt_uint64 = 1;

    msg.opt_sint32 = -42;
    msg.has_opt_sint32 = 1;

    msg.opt_sint64 = -4242424242LL;
    msg.has_opt_sint64 = 1;

    msg.opt_bool = 1;
    msg.has_opt_bool = 1;

    msg.opt_float = 3.14f;
    msg.has_opt_float = 1;

    msg.opt_double = 2.718281828;
    msg.has_opt_double = 1;

    /* strings/bytes: assign C-strings (protobuf-c expects char*) */
    msg.opt_string = strdup("hello optional");
    msg.has_opt_string = 1;

    /* bytes field: pointer + length stored as ProtobufCBinaryData in proto-c */
    static const uint8_t sample_bytes[] = {0xDE, 0xAD, 0xBE, 0xEF};
    msg.opt_bytes.data = malloc(sizeof(sample_bytes));
    memcpy((void*)msg.opt_bytes.data, sample_bytes, sizeof(sample_bytes));
    msg.opt_bytes.len = sizeof(sample_bytes);
    msg.has_opt_bytes = 1;

    /* nested message: allocate and initialize */
    Nested *nested = malloc(sizeof(Nested));
    nested__init(nested); /* generated init for Nested */
    nested->nid = 777;
    nested->has_nid = 1; /* presence inside nested */
    msg.opt_nested = nested; /* presence of nested usually by non-NULL pointer */

    /* enum optional */
    msg.opt_color = COLOR__GREEN;
    msg.has_opt_color = 1;

    /* oneof set to o_str */
    msg.o_str = strdup("oneof string");
    msg.opt_oneof_case = TEST_OPTIONAL__OPT_ONEOF_O_STR;

    /* repeated field */
    const int32_t repvals[] = { 11, 22, 33 };
    set_repeated_int32(&msg, 3, repvals);

    /* pack */
    size_t packed_size = test_optional__get_packed_size(&msg);
    uint8_t *buffer = malloc(packed_size);
    size_t wrote = test_optional__pack(&msg, buffer);
    assert(wrote == packed_size);

    /* free allocated memory that belongs to the original (but note protobuf-c does not free strings we allocated) */
    /* We'll free what we allocated after packing */
    free(msg.opt_string);
    free((void*)msg.opt_bytes.data);
    free(msg.opt_nested);
    free(msg.rep_int32);
    free(msg.o_str);

    /* Unpack */
    TestOptional *unpacked = test_optional__unpack(NULL, packed_size, buffer);
    assert(unpacked != NULL);

    /* Check presence flags for scalars */
    assert(unpacked->has_opt_int32 == 1);
    assert(unpacked->opt_int32 == 12345);

    assert(unpacked->has_opt_int64 == 1);
    assert(unpacked->opt_int64 == -1234567890123LL);

    assert(unpacked->has_opt_uint32 == 1);
    assert(unpacked->opt_uint32 == 4000000000U);

    assert(unpacked->has_opt_uint64 == 1);
    assert(unpacked->opt_uint64 == 900000000000ULL);

    assert(unpacked->has_opt_sint32 == 1);
    assert(unpacked->opt_sint32 == -42);

    assert(unpacked->has_opt_sint64 == 1);
    assert(unpacked->opt_sint64 == -4242424242LL);

    assert(unpacked->has_opt_bool == 1);
    assert(unpacked->opt_bool == 1);

    assert(unpacked->has_opt_float == 1);
    /* float compare approx */
    assert(fabs(unpacked->opt_float - 3.14f) < 1e-6f);

    assert(unpacked->has_opt_double == 1);
    assert(fabs(unpacked->opt_double - 2.718281828) < 1e-9);

    /* string/bytes */
    assert(unpacked->has_opt_string == 1);
    assert(strcmp(unpacked->opt_string, "hello optional") == 0);

    assert(unpacked->has_opt_bytes == 1);
    assert(unpacked->opt_bytes.len == sizeof(sample_bytes));
    assert(memcmp(unpacked->opt_bytes.data, sample_bytes, sizeof(sample_bytes)) == 0);

    /* nested */
    assert(unpacked->opt_nested != NULL);
    assert(unpacked->opt_nested->has_nid == 1);
    assert(unpacked->opt_nested->nid == 777);

    /* enum */
    assert(unpacked->has_opt_color == 1);
    assert(unpacked->opt_color == COLOR__GREEN);

    /* oneof check: should be O_STR */
    assert(unpacked->opt_oneof_case == TEST_OPTIONAL__OPT_ONEOF_O_STR);
    assert(strcmp(unpacked->o_str, "oneof string") == 0);

    /* repeated */
    assert(unpacked->n_rep_int32 == 3);
    assert(unpacked->rep_int32[0] == 11 && unpacked->rep_int32[1] == 22 && unpacked->rep_int32[2] == 33);

    /* Check a field we did NOT set: make sure presence is false */
    /* pick opt_double as example: we did set opt_double above, so check another field like opt_sint32? We set it.
       To test absence, we create a second message that leaves out a field: */
    TestOptional msg2 = TEST_OPTIONAL__INIT;
    msg2.opt_int32 = 5;
    msg2.has_opt_int32 = 1;
    /* msg2.opt_double not set -> has_opt_double should be 0 after pack/unpack */
    size_t ps2 = test_optional__get_packed_size(&msg2);
    printf("Packed size: %zu\n", ps2);
    uint8_t *buf2 = malloc(ps2);
    test_optional__pack(&msg2, buf2);
    TestOptional *un2 = test_optional__unpack(NULL, ps2, buf2);
    assert(un2 != NULL);
    /* opt_double was not set in msg2 */
    assert(un2->has_opt_double == 0);

    /* cleanup */
    test_optional__free_unpacked(unpacked, NULL);
    test_optional__free_unpacked(un2, NULL);
    free(buffer);
    free(buf2);

    printf("All optional presence tests passed.\n");
    return 0;
}
